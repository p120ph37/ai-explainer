/**
 * Variants Plugin for Bun
 * 
 * Scans editorial/variants/ directory and generates dynamic imports
 * for variant content. This allows variants to be hot-reloaded and
 * treated the same as base content nodes.
 * 
 * Resolves a virtual module `virtual:variants` that exports:
 * - variantImports: Record<string, () => Promise<VariantModule>>
 * - variantMeta: Record<string, VariantMeta>
 */

import { readdirSync, readFileSync, existsSync, statSync } from 'fs';
import { join, basename, dirname } from 'path';
import type { BunPlugin } from 'bun';

const VARIANTS_DIR = './editorial/variants';
const VIRTUAL_MODULE_ID = 'virtual:variants';

interface VariantInfo {
  id: string;           // e.g., "tokens/metaphor-voice"
  basePageId: string;   // e.g., "tokens"
  variantId: string;    // e.g., "metaphor-voice"
  filePath: string;     // e.g., "./editorial/variants/tokens/metaphor-voice.md"
  title: string;        // Extracted from H1
  summary: string;      // Extracted from first italic paragraph
  label: string;        // Display label (from filename)
}

/**
 * Scan the variants directory and extract metadata
 */
function scanVariants(): VariantInfo[] {
  const variants: VariantInfo[] = [];
  
  if (!existsSync(VARIANTS_DIR)) {
    return variants;
  }
  
  // Scan each page directory
  const pageDirs = readdirSync(VARIANTS_DIR);
  
  for (const pageDir of pageDirs) {
    const pagePath = join(VARIANTS_DIR, pageDir);
    if (!statSync(pagePath).isDirectory()) continue;
    
    // Scan variant files in this page directory
    const files = readdirSync(pagePath).filter(f => f.endsWith('.md') || f.endsWith('.mdx'));
    
    for (const file of files) {
      const filePath = join(pagePath, file);
      const variantId = basename(file, file.endsWith('.mdx') ? '.mdx' : '.md');
      const id = `${pageDir}/${variantId}`;
      
      // Extract title and summary from file content
      const content = readFileSync(filePath, 'utf-8');
      const titleMatch = content.match(/^#\s+(.+)\n/);
      const summaryMatch = content.match(/^#\s+.+\n+\*([^*]+)\*\n/);
      
      const title = titleMatch ? titleMatch[1] : formatLabel(variantId);
      const summary = summaryMatch ? summaryMatch[1] : '';
      
      variants.push({
        id,
        basePageId: pageDir,
        variantId,
        filePath: `./${filePath}`,
        title,
        summary,
        label: formatLabel(variantId),
      });
    }
  }
  
  return variants;
}

/**
 * Format a variant ID as a display label
 */
function formatLabel(variantId: string): string {
  return variantId
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

/**
 * Generate the virtual module code
 */
function generateVirtualModule(variants: VariantInfo[]): string {
  const imports = variants.map(v => 
    `  '${v.id}': () => import('${v.filePath}'),`
  ).join('\n');
  
  const meta = variants.map(v => 
    `  '${v.id}': {
    id: '${v.id}',
    basePageId: '${v.basePageId}',
    variantId: '${v.variantId}',
    title: ${JSON.stringify(v.title)},
    summary: ${JSON.stringify(v.summary)},
    label: ${JSON.stringify(v.label)},
    isVariant: true,
  },`
  ).join('\n');
  
  return `
/**
 * Auto-generated variant imports
 * This file is generated by variants-plugin.ts
 */

export const variantImports = {
${imports}
};

export const variantMeta = {
${meta}
};

export const variantIds = ${JSON.stringify(variants.map(v => v.id))};
`;
}

/**
 * The Bun plugin
 */
const variantsPlugin: BunPlugin = {
  name: 'variants-plugin',
  
  setup(build) {
    // Resolve the virtual module
    build.onResolve({ filter: /^virtual:variants$/ }, (args) => {
      return {
        path: args.path,
        namespace: 'variants',
      };
    });
    
    // Load the virtual module content
    build.onLoad({ filter: /.*/, namespace: 'variants' }, () => {
      const variants = scanVariants();
      const code = generateVirtualModule(variants);
      
      return {
        contents: code,
        loader: 'ts',
      };
    });
  },
};

export default variantsPlugin;
